% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.
%% \documentclass[preprint,10pt]{sigplanconf}
\documentclass{sigplanconf}

\usepackage{amsmath}

\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{Scheme and Functional Programming Workshop}{September 18th, 2016, Nara, Japan}
\copyrightyear{2016}
%% \copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
%% \copyrightdoi{nnnnnnn.nnnnnnn}
\publicationrights{author-pays}
%% \publicationrights{transferred}
%% \publicationrights{licensed}     % this is the default

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Function compose, Type cut, And the Algebra of logic}
%% \subtitle{Subtitle Text, if any}
\authorinfo{XIE Yuheng} {a math student of China} {xyheme@gmail.com}
\maketitle

\begin{abstract}
  In this paper, I demonstrate the Curry-–Howard correspondence of Gentzen's sequent calculus,
  and give a very rich algebraic structure of the corresponding deduction system.
  By such demonstration, I propose then a prototype implementation of a programming language, written in scheme, which uses sequent calculus as its dependent type system.
\end{abstract}

%% \category{CR-number}{subcategory}{third-level}

\keywords
language design,
dependent type,
deduction system,
sequent calculus,
algebraic structure.

\section{introduction}

\subsection{Curry--Howard correspondence of sequent calculus}

some said (for example, see the wikipedia page of ``Curry--Howard correspondence'', at the time when this paper is written),
in the framework of Curry--Howard correspondence,
Gentzen's sequent calculus does not correspond with
a well-defined pre-existing model of computation,
as it was for Hilbert-style and natural deduction.

in this paper, I will show that
we can get what sequent calculus corresponds to,
not by designing a new model of computation,
but by changing the syntax of well known model.

I will show that
sequent calculus corresponds to a functional programming language,
the syntax of which is optimized for function composition
instead of function application.

I will also show the trade-off of this syntax design. \\
(1) the syntax of type and function-body are unified. \\
(2) we lose the implicit syntax for currying. \\
(3) we gain the algebraic associative law.

\subsection{the Algebra of logic}

some also said (for example, see the first chapter of ``Homotopy Type Theory''),
deduction system can be viewed as algebraic structure,
where theorems are the elements (like elements of group),
where deductive rules are the operations (like multiplication of group).

in this paper, I will show that
with the associative law which we obtained from function composition,
the corresponding deduction system of our programming language
not merely ``can be viewed as'' algebraic structure,
but actually has a very rich algebraic structure.

\subsection{implementation}

I will also introduce a prototype implementation of such a language.
I call it ``sequent1''.

\section{background}

\subsection{how the idea was conceived}

two years ago,
for some reason, I learned the design of the stack-based language -- forth.
I began to write my own forth-like language,
and tried to add various features to it.
soon I found another forth-like language -- joy.
from joy I learned the composition v.s. application trade-off in syntax.

I added more and more features to my forth-like language.
things went well, until I tried to add a type system to the it.
I found that
to design a good type system,
a designer has to know Curry--Howard correspondence well.

and after some learning,
I figured that
the composition v.s. application trade-off in syntax,
corresponds to
the sequent-calculus v.s. natural-deduction in proof theory.

I tried to add such a sequent-calculus type system
to the forth-like language several times.
I failed.
because the implementation is written in assembly language,
the low-level detailed code would soon exceed the complexity
that a normal people like me can manage.

I steped back.
I decided to write a prototype language in scheme.
the prototype only limited to demonstrate the main idea of ``sequent-calculus as type system''.
thus I wrote ``sequent1''.

\subsection{related works}

there are many other works
that assign computational models to sequent-calculus-like logics.
for example:

{\scriptsize\begin{verbatim}
| people         | logic        | model                  |
|----------------+--------------+------------------------|
| Frank Pfenning | linear logic | concurrent programming |
|                |              |                        |
\end{verbatim}}

maybe one logic system can correspond to multiple computational models.
maybe more terminologys should be carefully coined,
and more general framework theory should be wisely designed,
to describe correspondences between deduction systems and computational models.

\section{the change of syntax}

I will introduce my syntax by comparing it with
the syntax of an imaginary agda-like (or idris-like) language. \\
I will mark its syntax by {\scriptsize\verb|<< application-language >>|}, \\
and I will mark my new syntax by {\scriptsize\verb|<< composition-language >>|}.

\subsection{natural number}

{\scriptsize\begin{verbatim}
<< application-language >>

data natural : type where
  zero : natural
  succ : natural -> natural

add : natural -> natural -> natural
add zero n = n
add (succ m) n = succ (add m n)

mul : natural -> natural -> natural
mul zero n = zero
mul (succ m) n = add n (mul m n)


;; note that,
;; in the following examples
;; ''~'' can be readed as ``define-function'',
;; ''+'' can be readed as ``define-type''.

<< composition-language >>

(+ natural (-> type)
   zero (-> natural)
   succ (natural -> natural))

(~ add (natural natural -> natural)
   (:m zero -> :m)
   (:m :n succ -> :m :n add succ))

(~ mul (natural natural -> natural)
   (:m zero -> zero)
   (:m :n succ -> :m :n mul :m add))
\end{verbatim}}

\subsection{detailed explanation of above example}

{\scriptsize\begin{verbatim}
(note
  the second arrow of the function body of
  (~ mul (natural natural -> natural)
     (:m zero -> zero)
     (:m :n succ -> :m :n mul :m add))
  which is
  (:m :n succ -> :m :n mul :m add)
  (note
    the antecedent of (:m :n succ -> :m :n mul :m add)
    is (:m :n succ)
    it can be viewed as 3 functions composed together
    the type of each of them are showed by the following list
    ((:m (-> natural))
     (:n (-> natural))
     (succ (natural -> natural)))
    the resulting type is
    (-> natural natural))
  (note
    the succedent of (:m :n succ -> :m :n mul :m add)
    is (:m :n mul :m add)
    it can be viewed as 4 functions composed together
    the type of each of them are showed by the following list
    ((:m (-> natural))
     (:n (-> natural))
     (mul (natural natural -> natural))
     (:m (-> natural))
     (add (natural natural -> natural)))
    the resulting type is
    (-> natural)))
\end{verbatim}}

\subsection{currying must also be explicit}

in type, input arguments and return values are made explicit. \\
instead of {\scriptsize\verb|(natural -> natural -> natural)|}, \\
we write {\scriptsize\verb|(natural natural -> natural)|}.

thus, in function body, currying must also be explicit.
we lost the implicit syntax for currying.
because currying is designed as a convention
for the syntax of function application.

\subsection{vector}

{\scriptsize\begin{verbatim}
<< application-language >>

data vector : natural -> type -> type where
  null : vector zero t
  cons : t -> vector n t -> vector (succ n) t

append : vector m t -> vector n t -> vector (add m n) t
append null       l = l
append (cons e r) l = cons e (append r l)

map : (m : a -> b) -> f a -> f b
map f null       = null
map f (cons e l) = cons (f e) (map f l)


<< composition-language >>

(+ vector (natural type -> type)
   null (-> zero :t vector)
   cons (:n :t vector :t -> :n succ :t vector))

(~ append (:m :t vector :n :t vector -> :m :n add :t vector)
   (:l null -> :l)
   (:l :r :e cons -> :l :r append :e cons))

(~ map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
   (null :f -> null)
   (:l :e cons :f -> :l :f map :e :f apply cons))
\end{verbatim}}

\subsection{unified syntax}

the syntax of type and function-body are unified.
a type is an arrow, a function-body is a list of arrows.

\subsection{different optimization of syntax}

\subsubsection{for function composition}

{\scriptsize\begin{verbatim}
<< application-language >>
compose : {A B C : type} (A -> B) -> (B -> C) -> (A -> C)
compose f g = λ x -> (f (g x))


<< composition-language >>

;; the syntax is optimized for function composition.
;; function composition is expressed by term concatenation.
\end{verbatim}}

\subsubsection{for function application}

{\scriptsize\begin{verbatim}
<< application-language >>

;; the syntax is optimized for function application.
;; function application is expressed by term concatenation.


<< composition-language >>

(~ apply (:a :b ... (:a :b ... -> :c :d ...) -> :c :d ...)
   (note it is implemented as a primitive-function))
\end{verbatim}}

\subsection{stack processing}

multiple return values are easily handled,
and stack-processing functions can be used to help to
re-order return values (without naming them) for function composition.
(just like in forth \& joy)

{\scriptsize\begin{verbatim}
<< composition-language >>

(~ drop (:t ->)
   (:d ->))

(~ dup (:t -> :t :t)
   (:d -> :d :d))

(~ over (:t1 :t2 -> :t1 :t2 :t1)
   (:d1 :d2 -> :d1 :d2 :d1))

(~ tuck (:t1 :t2 -> :t2 :t1 :t2)
   (:d1 :d2 -> :d2 :d1 :d2))

(~ swap (:t1 :t2 -> :t2 :t1)
   (:d1 :d2 -> :d2 :d1))
\end{verbatim}}

\section{the correspondence}

to show Curry–Howard correspondence under this syntax
is to show, \\
(1) how to view type as theorem? \\
(2) how to view function as proof?

\subsection{type as theorem}

with the ability to handle multiple return values,
we can express ``and'' easily.

{\scriptsize\begin{verbatim}
(A B -> C D) -- ``(A and B) implies (C and D)''
\end{verbatim}}

we can express ``for all'' and ``there exist'' in an unified way.

{\scriptsize\begin{verbatim}
((:x : A) -> :x P) -- ``for all x belong to A, we have P(x)''
(-> (:x : A) :x P) -- ``there exist x belong to A, such that P(x)''
\end{verbatim}}

I call expression of form {\scriptsize\verb|(A B C ... -> E F G ...)|} sequent.
but you should note that,
sequent for us, is not exactly the same as sequent for Gentzen.
Gentzen views succedent as ``or'', while we view succedent as ``and''.

{\scriptsize\begin{verbatim}
for Gentzen -- (A B -> C D) -- ``(A and B) implies (C or D)'',
for us      -- (A B -> C D) -- ``(A and B) implies (C and D)''.
\end{verbatim}}

\subsection{function as proof}

``function as proof'' means,
the way we write function body forms a language to record deduction.
a record of many steps of deduction is called a proof.

let us summarize deductive rules in sequent calculus in our language.
I will omit some explicit contexts variables in the deductive rules,
because in our language contexts can be implicit.

{\scriptsize\begin{verbatim}
f : (A -> B)
g : (B -> C)
-------------- cut
f g : (A -> C)

f : (A -> C)
------------------- left-weakening
drop f : (A B -> C)

f : (A A -> B)
---------------- left-contraction
dup f : (A -> B)

f : (A -> B B)
----------------- right-contraction
f drop : (A -> B)

f : (A B -> C)
------------------- left-permutation
swap f : (B A -> C)

f : (A -> B C)
------------------- right-permutation
f swap : (A -> C B)

f : (A -> C)
------------------- left-and-1
drop f : (A B -> C)

f : (B -> C)
------------------------ left-and-2
swap drop f : (A B -> C)

f : (A -> B)
g : (C -> D)
---------------------------- right-and
g swap f swap : (A C -> B D)

f : (A -> B)
------------------- right-or-1
f : (A -> (B or C))

f : (A -> C)
------------------- right-or-2
f : (A -> (B or C))

f : (A -> B)
g : (C -> D)
----------------------------- left-or
(case (:x {:x : A} -> :x f)
(:y {:y : C} -> :y g))
: ((A or C) -> (B or D))

f : (A -> B)
g : (C -> D)
-------------------------- left-implies
(:a :h -> :a f :h apply g)
: (A (B -> C) -> D)

f : (A B -> C)
----------------------- right-implies
(:x -> (:y -> :x :y f))
: (A -> (B -> C))
\end{verbatim}}

\subsection{examples}

{\scriptsize\begin{verbatim}
;; have-equal-human-rights

;; in the following example,
;; ``*'' can be readed as ``define-hypothesis''

(* rich-human (:x is-rich -> :x is-human))
(* poor-human (:x is-poor -> :x is-human))
(* human-have-equal-human-rights
   (:x is-human :y is-human -> :x :y have-equal-human-rights))

(~ rich-and-poor-have-equal-human-rights
   (:x is-rich :y is-poor -> :x :y have-equal-human-rights)
   (:ri :po -> :ri rich-human
               :po poor-human
               human-have-equal-human-rights))


;; map/has-length

(+ list (type -> type)
   null (-> :t list)
   cons (:t list :t -> :t list))

(~ map (:t1 list (:t1 -> :t2) -> :t2 list)
   (null :f -> null)
   (:l :e cons :f -> :l :f map :e :f apply cons))

(+ has-length (:t list natural -> type)
   null/has-length (-> null zero has-length)
   cons/has-length (:l :n has-length ->
                    :l :a cons :n succ has-length))

(~ map/has-length (:l :n has-length -> :l :f map :n has-length)
   (null/has-length -> null/has-length)
   (:h cons/has-length -> :h map/has-length cons/has-length))


;; natural-induction

(+ natural (-> type)
   zero (-> natural)
   succ (natural -> natural))

(~ natural-induction
   ((:p : (natural -> type))
    zero :p apply
    ((:k : natural) :k :p apply -> :k succ :p apply)
    (:x : natural) -> :x :p apply)
   (:q :q/z :q/s zero -> :q/z)
   (:q :q/z :q/s :n succ ->
       :n
       :q :q/z :q/s :n natural-induction
       :q/s apply))
\end{verbatim}}

\section{algebra of logic}

a concrete (not abstract) algebraic structure is rich when \\
(1) its elements have practical meaning. \\
(2) it is equipped with many algebraic laws, which you can use to transform equations.

a good example of such rich concrete algebraic structure
is the field of multivariate rational function
(i.e. quotient (or fraction) of multivariate polynomials),
which is studied in algebraic geometry.

since function composition already satisfies associative law,
we have the opportunity to demonstrate an rich algebraic structure,
the elements of which are formal theorems.

we will try to define those algebraic operations that are closed in the set of derivable theorems.
hopefully we will be able to capture all deductions by algebraic operations.

\subsection{to mimic fraction of natural number}

let us view theorem {\scriptsize\verb|(A -> B)|} as fraction,
{\scriptsize\verb|A|} as denominator,
{\scriptsize\verb|B|} as numerator.
-- just like {\scriptsize\verb|(A \ B)|}.
(note that,
we are using reverse-slash instead of slash,
to maintain the order of {\scriptsize\verb|A B|} in {\scriptsize\verb|(A -> B)|})

\subsection{multiplication}

to multiply two theorems {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(C -> D)|},
we get {\scriptsize\verb|(A C -> B D)|}.
-- just like {\scriptsize\verb|(A \ B) (C \ D) = (A C \ B D)|}.

{\scriptsize\begin{verbatim}
(* r (A -> B))
(* s (C -> D))

(~ r/s/mul (A C -> B D)
   (:x :y -> :x r :y s))

;; abstract it to a combinator
(~ general/mul
   ((:a -> :b) (:c -> :d) -> (:a :c -> :b :d))
   (:r :s -> (lambda (:a :c -> :b :d)
               (:x :y -> :x :r apply :y :s apply))))
\end{verbatim}}

theorems under multiplication is an Abelian group.
identity element is {\scriptsize\verb|(->)|}.
inverse of {\scriptsize\verb|(A -> B)|} is {\scriptsize\verb|(B -> A)|}.

\subsection{first definition of addition}

this definition recalls the fraction of natural number,
but it seems not natural when written as function in our language.

to add two theorems {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(C -> D)|},
we get {\scriptsize\verb|(A B -> (B C or A D))|}.
-- just like {\scriptsize\verb|(A \ B) + (C \ D) = (A C \ (B C + A D))|}.

{\scriptsize\begin{verbatim}
(* r (A -> B))
(* s (C -> D))

(~ r/s/fraction-add (A C -> (B C or A D))
   (:x :y -> :x r :y)
   (:x :y -> :x :y s))

;; abstract it to a combinator
(~ general/fraction-add
   ((:a -> :b) (:c -> :d) -> (:a :c -> (:b :c or :a :d)))
   (:r :s -> (lambda (:a :c -> (:b :c or :a :d))
               (:x :y -> :x :r apply :y)
               (:x :y -> :x :y :s apply))))
\end{verbatim}}

distributive is just like fraction of natural number,
because the way we define addition
is just like the addition of fraction of natural number.

theorems under addition is an Abelian semigroup.
we do not have identity element,
and we do not have inverse.
- of course, we can introduce a ``zero-theorem''
  (a theorem that we can never prove)
  as the identity element of addition,
  to make our algebraic structure more like fraction of natural number.

under this definition of addition,
one may call the algebraic structure ``natural field'',
to recall its similarites between the fraction of natural number.
- note that,
  other terms like 'semi-field' is ambiguous.
  because it does not inform us
  whether we mean addition is semi or multiplication is semi.

\subsection{second definition of addition}

this definition seems more natural in our language.

to add two theorems {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(C -> D)|}, \\
we get {\scriptsize\verb|((A or B) -> (C or D))|}.

{\scriptsize\begin{verbatim}
(* r (A -> B))
(* s (C -> D))

(~ r/s/mul-like-add ((A or C) -> (B or D))
   (:x {:x : A} -> :x r)
   (:y {:y : C} -> :y s))

;; abstract it to a combinator
(~ general/mul-like-add
   ((:a -> :b) (:c -> :d) -> ((:a or :c) -> (:b or :d)))
   (:r :s -> (lambda ((:a or :c) -> (:b or :d))
               (:x {:x : :a} -> :x :r apply)
               (:y {:y : :c} -> :y :s apply))))
\end{verbatim}}

distributive also hold under this definition of addition, \\
because {\scriptsize\verb|(-> A (B or C))|} is the same as {\scriptsize\verb|(-> (A B or A C))|}.

theorems under addition is an Abelian semigroup.
identity element is {\scriptsize\verb|(->)|},
but we do not have inverse.

\subsection{term-lattice, and cut as weaken}

this is where we must take term-lattice into account.

{\scriptsize\begin{verbatim}
| term                   | lattice          |
|------------------------+------------------|
| unification (uni)      | meet             |
| anti-unification (ani) | join             |
| cover (or match)       | greater-or-equal |
\end{verbatim}}

(note that, ``equal'' can be defined by ``greater-or-equal'')

term-lattice is also called ``subsumption lattice'' by other authors.
I call it ``term-lattice'',
because I want to make explicit its relation with term-rewriting-system
(I will address the detail of term-lattice in another paper).

if we have {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(C -> D)|}, \\
we can cut them only when {\scriptsize\verb|(C cover B)|}. \\
for example, when:

{\scriptsize\begin{verbatim}
    (1) C = B
    (2) C = (B or E)
    (3) C = :x :y P
        B = :x :x P
\end{verbatim}}

cut can be viewed as an important way to weaken a theorem.
we can first multiply {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(C -> D)|} to {\scriptsize\verb|(A C -> B D)|},
then weaken it to {\scriptsize\verb|(A -> D)|}, provides that {\scriptsize\verb|(C cover B)|}.

we can also extend the lattice operations to cedent (antecedent and succedent),
because cedent is Cartesian product of term.

\subsection{equality of theorem}

we can define {\scriptsize\verb|A == B|}, as {\scriptsize\verb|(A -> B)|} and {\scriptsize\verb|(B -> A)|}.

\subsection{constructiveness}

in our language, we have the following keywords to do definitions:

{\scriptsize\begin{verbatim}
| keyword | read as                                | function-body |
|---------+----------------------------------------+---------------|
| ``+''   | define-type, define-data               | trivial       |
| ``~''   | proof, define-theorem, define-function | non-trivial   |
| ``*''   | assume, define-hypothesis              | no            |
\end{verbatim}}

whenever we have function-body, be it trivial or non-trivial,
we can use it to rewrite data.

for example, \\
the function-body of {\scriptsize\verb|succ|} is trivial, \\
it rewrites {\scriptsize\verb|zero|} to {\scriptsize\verb|zero succ|}, \\
i.e. merely add a symbol to the data. \\
while the function-body of {\scriptsize\verb|add|} is non-trivial, \\
it rewrites {\scriptsize\verb|zero succ zero succ|} \\
to {\scriptsize\verb|zero succ succ|}.

whenever we use ``*'' to introduce a hypothesis,
the constructiveness of function is lost,
although we still can use it to define functions
and type check the definitions,
we can not use it to rewrite data.
(but abstractiveness is gained,
I will address the detail of the balance
between constructiveness and abstractiveness in another paper)

\subsection{algebraic extension}

then defining a new types by ``+'',
we provide a type-constructor,
and a list of data-constructors.

by introducing such constructors,
we are extending our algebraic structure.
(just like field extension by root of equations)

\section{implementation}

I made an attempt to implement a prototype of the language,
project page at {\scriptsize\verb|http://xieyuheng.github.io/sequent1|}

\subsection{implementation-tech}

during writing the prototype language,
I noticed the language is not necessarily stack-based.
and we have the following relations:

{\scriptsize\begin{verbatim}
| implementation-tech     | the natural of language       |
|-------------------------+-------------------------------|
| stack-based computation | call-by-value (non-lazy-eval) |
| term-rewriting-system   | call-by-name (lazy-eval)      |
| graph-rewriting-system  | call-by-need (lazy-eval)      |
\end{verbatim}}

first few versions of sequent1 is implemented as a stack-based language,
only later, changed to term-rewriting-system.
because we have to handle lazy-trunk in the language,
and in a term-rewriting-system,
I can handle lazy-trunk in an unified implicit way.

\subsection{mistakes in my implementation}

this prototype has the following mistakes
to be fixed in the next versions of the prototype.

(1) I fail to far see that
the structure of reports, which returned by various checkers,
must be highly structured data, instead of string.
thus, I fail to print useful reports when checkers find mistakes in code.

(2) I know graph-rewriting-system is needed,
but I did not implement the language by it.
because I want to keep the prototype simple.

(3) can not handle mutual recursive function.

(4) can not handle un-named ``or''.

(5) the meaning of equality is not fully understood.

(6) not yet designed a good mechanism for abstractiveness.

\subsection{further work}

I planed to

(1) develop the algebra of logic further.

(2) handled ``equality'' carefully,
and use the language as a concrete tool
to investigate algebraic topology.

\subsection{conclusion}

\acks

I would like to thank my friend Jason Hemann, for his very valuable advice about this paper.

\bibliographystyle{abbrvnat}
% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
  \softraggedright
  %% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
  %% P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
